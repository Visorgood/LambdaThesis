\section{Speed layer}

Real-time part consists only of speed layer.
Speed layer provides real-time views.
They contain sketches of data, that is being obesrved during ongoing batch processing in the batch layer.
Speed layer is much more complex than batch layer, because of its incremental nature.
And it provides only approximated results.
We discuss each layer in more details in particular chapters.

To overcome delay of batch processing the Lambda architecture uses online incremental processing of arriving data.
It maintains additional data structures, called real-time views.
They store information, derived from data arriving during current batch processing.
Real-time views are normally different from batch views, and also more complex.
That is because they must be updated and available continuously, as new data arrives.
This demands usage of such techniques like sketch algorithms.
It is described in all details in the particular chapter.
It worth to mention that real-time views contain often approximated information, because of requirements they must obey.
But that is not a crucial problem, because they do not accumulate error for a too long time.
Real-time view exists only during current batch processing.
When it is done, real-time views are dropped, and start to be created from the beginning.

The main purpose of the speed layer is the same as of batch part - to answer queries.
As long as the batch layer computes views for several hours, speed layer is dedicated to cover this interval, providing low-latency answers.
During the time of current batch processing, data coming to the system is stored to master dataset as well as added incrementally to the real-time views in speed layer.

This ability to update views on the fly makes speed layer much more complex.
It involves usage of databases, that allow random writes.
Algorithms, used to make online stream processing, are also usually more complex.
Because of those issues, speed layer is more error prone, and takes more effort from developer.
But real-time views are discarded every time, when batch layer completes processing of batch views.
Such temporal nature of real-time views saves us from accumulation of error.
This property of the Lambda architecture is called \textit{complexity isolation}\mnote{complexity isolation}.

\subsection{Computaition of real-time views}
To compute real-time views, one could consider the same approach as for batch views, but use only new data for computations.
This would simulate batch processing on the much smaller scale.
Nevertheless, if we want to achieve latency of miliseconds, such approach is not going to work.
Batch processing even on the scale of several gigabytes is not possible to do in miliseconds.

To solve this issue we have to use completely different approach.
We do not consider the whole bunch of data, that has arrived during current batch processing, for creating real-time views.
Instead, we incrementally update them with a small piece of data, everytime it arrives.
This normally leads to only an approximated answers to the queries, provided by real-time views.
But this is again not a problem, because error does not accumulate for too long.

\subsection{Storage of real-time views}
Speed layer must obey low-latency requirement, and must allow to apply complex
incemental algorithms.
Having such demands, storing of real-time views requires much more properties
to be fulfilled:
1. Ability to make random reads. This is particularly important to make
answering queries fast.
2. Ability to make random writes. This is necessary, because we want to apply
incremental algorithms, that always demand this property.
3. Real-time view must be scalable, because amount of data to process can still
be of a huge size. That means, that distribtuion to many machines must be
possible.
4. Fault-tolerance is as usual an issue. Replication of real-time views is then
to accomplish.

Databases, that commonly obey these properties, are called \textit{NoSQL databases}\mnote{NoSQL databases}.
They store data using different data models.
One can choose specific database, that obeys his or her requirements to data
representation.
Sometimes batch and real-time views stores data in the same format.
But it is not always the case, because it is not always easy to execute the
same function in the batch and in the incremental way.
Also, as long as real-time views provide only temporal information, it is
usually possible to simplify data representation, becoming small approximation
error.
Because of those factors, it often happens, that your real-time views represent
data differently, than batch views.

\subsection{Issues of incremental computations}
Incremental computations are opposite to batch computations.
Batch computations imply, that we take the whole dataset, and compute
specific function on it.
This is usually easy to program, even though can take much time.

In case of incremental computations, we build specific data structure
continuously.
This data structure is called real-time view in our context.
It must be possible to update this data structure as well as to make requests
answering queries fast.
This two properies are the key to low-latency requirement satisfaction.