\subsection{Redis [VI]}

Redis is an open source key-value in-memory data storage \cite{Seguin2012} \cite{Redis}.
It affords blazingly fast and simple tool for maintaining data inside of a single application or a cluster.
Redis is very easy to deploy, learn and use.
It provides 5 data structures, e.g. string, list, set, ordered set and hash, that are useful for different tasks, and give a powerful tool in combination.

\subsubsection{Basics}

Redis is a key-value store, that allows to hold all data of your application.
Redis lets to create many databases and switch between them.
For one database it maintains one global map of keys to values.
Although Redis is in-memory database system, it swaps data continuously to disk to provide persistance in case of application's failure.
This is also important in a distributed environment to have global data available between applications.

Record in Redis is a key-value pair.
The key is always a string.
It does not contain data, that your application manipulates, but it identifies piece of data, that you want to store.
The value can be of different types, but in any case it is a meaningful peace of data, that you store in the database.

Redis provides many useful and at the same time simple commands to work with data.
The two simplest commands are $SET$ and $GET$, that let to store a key-value pair into database, and to get value by key, respectively.
This is an example of how you can use these commands:
\begin{verbatim}
> SET server:name "SERVER1"
OK
> GET server:name
"SERVER1"
\end{verbatim}
There are many commands to work with data structures, that Redis provides.

Redis allows to query only values by keys.
You cannot find a key, this is a crucial difference with classical relational databases.
And if you do not know a key, you can not find a value.
There is a command $keys$, that returns all keys, stored in the database, but it is strongly advised not to use it in production application, because it does a linear scan through all the keys, what can be very slow.
Another point is that operation of receiving a value by a key works in constant time, basically instantly.
This makes Redis blazingly fast and useful, because grow of the database does not affect its performance.

Redis stores the database to disk every minute if at least 1000 keys has been changed.
It makes less swaps, if you change less number of keys.
It does swap completely as a snapshot.
There is an alternative way to set Redis to make appending swaps.

\subsubsection{Data structures}

The basic data structure in Redis is a \textit{String}.
Keys are always strings.
Values can be of any type, but String is the most popular, because it represents atomic piece of data.
As a String you can store not just something simple like name of a user or his password, but also complex objects like JSON object, for example:
\begin{verbatim}
> SET users:user001 '{"firstname": "john", "lastname": "smith"}'
OK
\end{verbatim}
Redis provides standard commands to work with strings, e.g. $STRLEN$, $GETRANGE$, $APPEND$, etc.
If you store numeric value as a string, you can work with it as with integer.
Redis has several useful commands for this case, e.g. $INCR$, $INCRBY$, $DECR$, $DECRBY$, $SETBIT$, $GETBIT$.

The first complex data structure is \textit{List}.
List is simply an array of values identified by a key.
There are specific commands to work with lists, e.g. $LPUSH$, $RPUSH$, $LRANGE$, $LLEN$, $LPOP$, $RPOP$, etc.
The values of the list can by anything, not only strings.
This gives powerful tool to store complex combined data.
\begin{verbatim}
> LPUSH users john mike jack
(integer) 3
> LRANGE users 0 -1
1) "jack"
2) "mike"
3) "john"
\end{verbatim}

The next data structure is \textit{Set}.
Set is an unordered array of distinct values.
There are many useful operations with sets in Redis, e.g. $SADD$, $SISMEMBER$, $SINTER$, $SINTERSTORE$, etc.
Sets are implemented internally as a hash-table, hence, they provide constant lookup.
\begin{verbatim}
> SADD friends:john mike paul jack tania
(integer) 4
> SISMEMBER friends:john paul
(integer) 1 
\end{verbatim}

\textit{Sorted set} is a extension of a regular Set, that provides order for its elements.
To order values, it uses scores.
Each value has then a score, when you put it into Sorted set.
You can then lookup all values in the specified range of the score, or obtain all values in the sorted order.
Main commands for working with Sorted set are $ZADD$, $ZCOUNT$, $ZRANK$, $ZREVRANK$, etc.
In case you need array sorted by integers, Sorted set is a perfect data structure to do that.
\begin{verbatim}
> ZADD friends:john 70 mike 95 paul 92 jack 75 tania 1 dave
(integer) 5
> ZCOUNT friends:john 90 100
(integer) 2
\end{verbatim}

\textit{Hash} is the last data structure given in Redis.
Hash is essentially a hash-table, that maps strings to any objects.
It works also in constant time.
There are different commands to work with Hash, e.g. $HSET$, $GHET$, $HMSET$, $HMGET$, $HGETALL$, $HKEYS$, $HDEL$, etc.
Hashes give simple useful tool to store objects in an object-oriented way.
For example, instead of storing information about user as a JSON object, or as another string representation, you can do it using Hash.
You then put every field of a user as a separate key-value pair.
\begin{verbatim}
> HSET users:john id 375
(integer) 1
> HSET users:john name "john"
(integer) 1
> HSET users:john lastname "smith"
(integer) 1
> HGETALL users:john
1) "id"
2) "375"
3) "name"
4) "john"
5) "lastname"
6) "smith"
\end{verbatim}

\subsubsection{Features}

Redis allows to use transactions to make several operations atomic.
Basically, any operation that Redis does, is essentially atomic, because Redis is single-threaded server.
If you execute any single command, no other command can start execution before your is in progress.
But sometimes it is useful or even necessary to do several opearations in line as one atomic command.
For that case Redis provides transactions.
\begin{verbatim}
MULTI
...
EXEC
\end{verbatim}
This is how you use transactions in Redis.
All commands between $MULTI$ and $EXEC$ is one atomic operation.

Redis allows you to make expiration time for a key, or set an expiration point in time for a key using Unix timestamp.
This can be done using commands $EXPIRE$ and $EXPIREAT$.
\begin{verbatim}
EXPIRE user001 20
EXPIREAT user001 1457243611
\end{verbatim}
It does not important, what data structure key identifies.
When a key expires, it does not exist in Redis anymore.
To check expiration time for a key there is a command $TTL$.
To remove expiration from a key, you can use command $PERSIST$.

There is a mechanism of subscribtion and publication in Redis.
You can subscribe to a channel using command $SUBSCRIBE$.
When somebody publishes something to this channel using command $PUBLISH$, you receive this message where you subscribed for it.
This tool allows to notify different nodes in the system, that connect to Redis database, about events.

Redis has a very useful command $SORT$, that allows to sort lists, sets and sorted sets by their values.
When you apply this command to a collection, it returns elements in a sorted order.
There are different parameters, to say this command how you want to execute sorting.
This is a simple example of how you can use $SORT$ command:
\begin{verbatim}
> RPUSH simple_array 3 12 7 1 4 8 2 9
(integer) 8
> SORT simple_array
1) "1"
2) "2"
3) "3"
4) "4"
5) "7"
6) "8"
7) "9"
8) "12"
\end{verbatim}

Redis allows to use Lua scripts.
Lua is a scripting language.
You can write a script, store it, and then use directly from Redis.
This provides useful feature, that gives an opportunity to write your own commands, that contain several operations, logically united in one meaningful operation.
Such defined procedure executes in atomic way, what is another advantage.